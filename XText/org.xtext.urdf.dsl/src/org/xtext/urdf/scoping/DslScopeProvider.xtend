/*
 * generated by Xtext 2.10.0
 */
package org.xtext.urdf.scoping

import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.xtext.urdf.myURDF.DotExpression
import org.xtext.urdf.myURDF.Joint
import org.xtext.urdf.myURDF.Link
import org.xtext.urdf.myURDF.ReUsableRef
import org.xtext.urdf.myURDF.ReUseAble
import org.xtext.urdf.myURDF.Reuse
import org.xtext.urdf.myURDF.Robot
import org.xtext.urdf.myURDF.Topology

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 * 
 * SPECIFICATION:
 * 
 * Topology (parent): Able to see links defined below in document (default?)		TODO
 * Topology (parent): Not see links already used in this topology chain?			TODO 
 * Link (isReuse): Only see links that are not already made from reuse or self		DONE
 * Link (isReuse): Also see links defined below in document (default?)				TODO
 * Link (isReuse): Also see links made from Topology (default)						DONE
 * AddToLink (link): Should only see links made from Topology?						TODO
 * AddToJoint (joint): Should only suggest joints made from Topology?				TODO
 * DotExpr (tail): Only available in context										? 
 * ReUseAble (reuseable): Only current being reused									? 
 * Joint (isReuseOf): Only see joints that are not already made from reuse or self	DONE
 * Joint childOf: Any further restrictions needed?									?
 * Joint (parentOf): Should only see links that do not already have a parent 		?   
 * Joint (parentOf): Should only see links that is not already child of this 		DONE
 * SHOULD WE LIMIT VISIBILITY OF VISUAL TO LINK (reuse name)
 * 
 */
 
class DslScopeProvider extends AbstractDslScopeProvider {
	@Inject IQualifiedNameProvider URDFQualifiedNameProvider;
	//@Inject IResourceSetProvider resourceSetProvider;
	
	override IScope getScope(EObject context, EReference reference) {
	
		
		//Get Robot for further ref below
		val robot = EcoreUtil2.getContainerOfType(context, Robot)
		
		//Make sure all links are visible... 
		if (context instanceof Robot) {
//			val test = context 
			if(reference.name.equals("parent")) {
				if (!robot.links.empty) Scopes.scopeFor(robot.links)
				else return IScope::NULLSCOPE
			}
			else super.getScope(context, reference)
			
		}
		
		//If we are inside Topology Chain - check upstream links for cyclic ref (to not suggest invalid)
		if (context instanceof Topology) {
//			val topo = reference.name.equals("parent")
//			val cont = context.eContainer
			if(context.eContainer instanceof Topology && reference.name.equals("parent")) {
				
//				val me = context.parent
//				val parent = context.eContainer as Topology 
//				val test = parent.parent.name
				val previous = EcoreUtil2.getAllContainers(context).filter(Topology).map[x | x.parent].toList
				val with_parents = robot.joint.map[z | z.parentOf].toSet
				
				if (with_parents == null || with_parents.isEmpty)
					  return IScope::NULLSCOPE
				
				
				val links_no_previous = robot.links.filter[x | !previous.contains(x)].
													filter[y | !y.name.equals(context.parent.name)].
													filter[z | !with_parents.contains(z)]
				
				if (links_no_previous.empty) return IScope::NULLSCOPE
				else return Scopes.scopeFor(links_no_previous)
			}
			else super.getScope(context, reference)
		}
		
				
		//Link (isReuse): Only see links that are not self - or already reuse of
		if (context instanceof Link) {
			if (reference.name.equals ("isReuseOf")) {
				return Scopes.scopeFor(robot.links.
					filter[x | !x.name.equals(context.name)].
					filter[y | y.isReuseOf == null]
				)
			}
		}
		
		//Jont (isReuseOf): Only see links that are not self - or already reuse of
		if (context instanceof Joint) {
			if (reference.name.equals("isReuseOf")) {
				return Scopes.scopeFor(robot.joint.
				filter[x | !x.name.equals(context.name)].
				filter[y | y.isReuseOf == null]
				)
			}
			//Only suggest links that do not already have parent  
//			if (reference.name.equals("parentOf")) {
//				val available = robot.links.			
//					filter[x | x != context.childOf].
//					filter[y | !robot.joint.map[z | z.parentOf].toSet.contains(y)]
//				
//				if (!available.empty) Scopes.scopeFor(available)
//				else return IScope::NULLSCOPE
//			}
			else super.getScope(context, reference)
			
		}
		
		if (context instanceof Reuse) {		
			//Return scope for edit inside dot expression = currently reused
			if (context.eContainer instanceof Link) {
				val curr = EcoreUtil2.getContainerOfType(context, Link)
				return Scopes.scopeFor(newArrayList(curr.isReuseOf).toList)
			} else {
				val curr = EcoreUtil2.getContainerOfType(context, Joint)
				return Scopes.scopeFor(newArrayList(curr.isReuseOf).toList)
			}
			
	    }
	    
 		else if (context instanceof DotExpression) {
			val head = context.ref
		 	switch (head) {
		 		//Iteration on dot - just return contents of reused
            	ReUsableRef : {
            	Scopes::scopeFor(head.reuseable.eContents, URDFQualifiedNameProvider 
                					, IScope::NULLSCOPE)
                }		               					
 
            	DotExpression : {
                	val tail = head.tail
                	if (tail != null) {
                		switch (tail) {
         					ReUseAble :  Scopes::scopeFor(tail.eContents,  
                						URDFQualifiedNameProvider, 
                						IScope::NULLSCOPE)
                		    default: IScope::NULLSCOPE
                		}
                	} 
                	else Scopes::scopeFor(head.eContents) 
             	}
        	}   
 		}
		
		//if no custom rule applies - delegate to default scope impl....
		else super.getScope(context, reference)

	}
	
}
