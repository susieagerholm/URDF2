/*
 * generated by Xtext 2.10.0
 */
package org.xtext.urdf.validation

import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.xtext.urdf.myURDF.AssignNewValue
import org.xtext.urdf.myURDF.Axis
import org.xtext.urdf.myURDF.DotExpression
import org.xtext.urdf.myURDF.Joint
import org.xtext.urdf.myURDF.Link
import org.xtext.urdf.myURDF.MyURDFPackage
import org.xtext.urdf.myURDF.Robot

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DslValidator extends AbstractDslValidator {

	@Check
	def parentCheck(Robot robot) {
		val test = new CyclesValidator().parentCheck(robot.topologies);
		if(test.validationError) {
			error("Multiple parents. The following link has 2 parents: " + test.errorLink.name, MyURDFPackage.Literals.ROBOT__TOPOLOGIES)
		}
	}

	@Check
	def oneRoot(Robot robot) {
		var RootCheck test = new CyclesValidator().oneRoot(robot.getTopologies())
		if (test !== null && test.isValidationError()) {
			var String displayLine = null
			if (test.toString().contains("->")) {
					displayLine = '''Multiple roots problem. These topologies qualify as roots, but their starting link is not unique: «test.toString()»'''
				} else {
					displayLine = '''Multiple roots problem. «test.toString()»'''
				}
				error(displayLine, MyURDFPackage.Literals.ROBOT__TOPOLOGIES)
			}
	}

	@Check
	def checkNoCyclicReferences(Robot robot) {
		val test = new CyclesValidator().cycles(EcoreUtil2.copy(robot),false);
		if(test!=null) {
				error("Cyclic error. Problem with link: " + test, MyURDFPackage.Literals.ROBOT__LINKS)			
		} 
	}	
	
	 //A Robot must contain at least one Link to be valid instance
    @Check
	def checkRobotContainsLink(Robot robot) {
		if (robot.links.length < 1)
		error("A Robot must contain at least one Link to be valid instance", 
        		MyURDFPackage.Literals.NAMED_ELEMENT__NAME)
	}
	
	// Equal operators - Java vs Xtend:
	// Xtend: The equals operators (==,!=) are bound to Object.equals, eg. if (name == 'Homer')  a literal test
	// Xtend: The tripple-equals operators (===,!==) is mapped to Identity equals  if (someObject === anotherObject)
	

	//Link name must be unique
	
//	@Check
	def uniqueNameOfLinkRequired(Link linkk) {
		val robot = EcoreUtil2.getContainerOfType(linkk, Robot)
		if(robot.links.exists[ x | if (x!==linkk) x.name.equals(linkk.name) ])
			error("Link name has to be unique. Another link already has this name", 
				MyURDFPackage.Literals.NAMED_ELEMENT__NAME)
	}
	
	//Joint name must be unique
//	@Check
	def uniqueNameOfJointRequired(Joint jointt) {
		val robot = EcoreUtil2.getContainerOfType(jointt, Robot)
		if(robot.joint.exists[x | if(x!==jointt)  x.name.equals(jointt.name)])
			error("Joint name has to be unique. Another joint already has this name", 
				MyURDFPackage.Literals.NAMED_ELEMENT__NAME)	
	}
	
//	@Check
    //Check that assigned value in Reuse - edit is of same type as edited
	def allAssignmentOfNewValueMustMatch(AssignNewValue assign) {
		val mytail = (assign.getRef as DotExpression).tail
		if (mytail != null) {
			if (mytail.class != assign.newReuseable.class) {
				error("The item chosen for edit is of type " + mytail.class.name + " which is not of the same type as the assigned value, which is of type" + assign.newReuseable.class.name, 
        		MyURDFPackage.Literals.ASSIGN_NEW_VALUE__NEW_REUSEABLE)
			} 
		}
		
	}
		
	// A Joint of type revolute or prismatic must have Limit defined
	@Check
	def checkJointTypesHaveRequiredLimit(Robot robot) {
		if (!robot.joint.filter[j | j.type.getName.equals("revolute") || j.type.getName.equals("prismatic")].forall[j | j.limit != null])
		error("A Joint of type revolute or prismatic must have a Limit defined", 
        		MyURDFPackage.Literals.NAMED_ELEMENT__NAME)
	}
	
	// A Joint of type revolute or prismatic must have Axis defined
	@Check
	def checkJointTypesHaveRequiredAxis(Robot robot) {
		if (!robot.joint.filter[j | j.type.getName.equals("revolute") || j.type.getName.equals("prismatic")].forall[j | j.axis != null])
		error("A Joint of type revolute or prismatic must have an Axis defined", 
        		MyURDFPackage.Literals.NAMED_ELEMENT__NAME)
	}
	
	
	//An Axis may have only one active vector...
	@Check
	def checkAxisSettingIsValidOnlyOneActiveVector(Axis axis) {
		if(axis.x.value + axis.y.value + axis.z.value != 1)
		error("Only one of the vectors of an Axis may be set to 1 (= active). The other two vectors must be set to 0", 
        		MyURDFPackage.Literals.NAMED_ELEMENT__NAME)	
	}
	
	@Check
	def onlyPossibleToReuseIfNotAlreadyReused(Link reuser) {
		if(reuser.isReuseOf.isReuseOf != null) 
			error("Not legal to reuse from a link, that is already made from reuse", 
        		MyURDFPackage.Literals.NAMED_ELEMENT__NAME)
	}	
	
	@Check
	def overwriteAttributeWarning(Link reuser) {
		val overwrite = new OverwriteValidator().overwrite(reuser);
		if(overwrite) {
			warning("You are overwriting an existing value - are you nuts!", 
    		MyURDFPackage.Literals.LINK__REUSE)
		}
	}

	@Check
	def overwriteInertial(Link reuser) {
		val overwrite = new OverwriteValidator().overwriteInertial(reuser);
		if(overwrite) {
			warning("There can only be one inertial in a link, and you have added a new inertial. The previously defined value is overwritten", 
    		MyURDFPackage.Literals.LINK__REUSE)
		}
	}

	@Check
	def overwriteJoint(Joint joint) { 
		val overwrite = new OverwriteValidator().overwriteJoint(joint);
		if(overwrite) {
			warning("A joint can max have one of each of the types: Origin, Limit, Axis, Dynamics, Calibration and SafetyController.
					 You are now trying to add a new of one of these types, so the previous type will be overwritten", 
    		MyURDFPackage.Literals.JOINT__TYPE)
		}
	}

	@Check
	def overwriteInertialFromTopo(Robot robot) { 
		val overwrite = new OverwriteValidator().overwriteInertialFromTopo(robot);
		if(overwrite) {
			warning("There can only be one inertial in a link, and you have added a new inertial. The previously defined value is overwritten", 
    		MyURDFPackage.Literals.ROBOT__ADDTO)
		}
	}

	@Check
	def overwriteJointFromTopo(Robot robot) { 
		val overwrite = new OverwriteValidator().overwriteJointTypesFromTopo(robot);
		if(overwrite) {
			warning("A joint can max have one of each of the types: Origin, Limit, Axis, Dynamics, Calibration and SafetyController.
					 You are now trying to add another of one of these types, so the previous definition will be overwritten", 
    		MyURDFPackage.Literals.ROBOT__ADDTO)
		}
	}


	@Check
	def onlyPossibleToReuseIfNotAlreadyReused(Joint reuser) {
		if(reuser.isReuseOf.isReuseOf != null) 
			error("Not legal to reuse from a joint, that is already made from reuse", 
        		MyURDFPackage.Literals.NAMED_ELEMENT__NAME)
	}	
	

 
/*	
	@Check
	def checkNoJointHasSameLinkAsParentAndChild (Joint joint) {
      if(joint.childOf === joint.parentOf)
      	error("Cyclic reference problem: Joint has same link as parent AND child creating a loop", 
					MyURDFPackage.Literals.NAMED_ELEMENT__NAME)
      
    }
*/    
    /*2.d? No two joints may have the same parentOf/childOf combination  
	* 
	* */
/*	
	@Check
	def checkNoTwoJointsHaveSameParentAndChildCombination (Joint joint) {
		val robot = EcoreUtil2.getContainerOfType(joint, Robot)
		if(robot.joint.exists[x | 
			(x.childOf.name.equals(joint.childOf.name) && x.parentOf.name.equals(joint.parentOf.name)) ||
			(x.childOf.name.equals(joint.parentOf.name) && x.parentOf.equals(joint.childOf.name))
		])
		error("Cyclic reference problem: Joint has same link as parent AND child combination as other joint creating a loop ", 
					MyURDFPackage.Literals.NAMED_ELEMENT__NAME)
	}
*/	
	
	
}