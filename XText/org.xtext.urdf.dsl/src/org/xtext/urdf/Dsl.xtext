
grammar org.xtext.urdf.Dsl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.itu.dk/uRDF"
//import "http://www.example.org/uRDF" as uRDF
//generate myURDF "http://www.itu.dk/uRDF"


/*
 * Todo: 
 * Expressions - inline for value assignment 
 * Add Constant to parser rules: Should be alternative in all numeric expr - and for ID with String value  
 * Topology of Link and Joint: How to specify?
 * Add reflect as alternative in relevant places...
 * Add reuse grammar with reference to reused entity (mydot example from christian not working!)
 * Create ValueConverter (and possibly other stuff to parse reflect as negation of reused)
 * Create ValueConverter to convert scale values to Box
 * DONE: Create Constants datatype - signed numeric or string (incl concatenation with String)
 * DONE: Change interface to abstract class in metamodel
 * DONE: ReUse - add reference in the metamodel
 * DONE: Origin required should possibly be adjusted in metamodel?
 * DONE: Scientific notation - how to implement?
 * DONE: Origin xyz/rpy values + axis values - vector and single defs. Kill one of the definitions?
 * DONE: Origin values should be ('-')? INT or FLOAT or SCIENTIFIC - get SIGNED_NUMERIC class from metamodel...
 */


Robot:
	'Robot' name=ID
	 ('Topology' topologies+=Topology | link+=Link | joint+=Joint | linkrefs+=LinkRef)*
	 //usage+=Usage*
;

ReUseAble:
	Link | Joint 
;
/* 
Usage returns Usage:
    "use" ref=DotExpression
;

DotExpression returns Ref:
    EntityRef ({DotExpression.ref=current}  "." tail=[ecore::EStructuralFeature])*       //Compiler ikke
    //EntityRef ({DotExpression.ref=current}  "." tail=[ReUseAble])*                  // Ok
;
* 


EntityRef returns Ref:
    {EntityRef} entity=[ReUseAble]
;
*/

Topology:
	parent=[Link|ID] (joint=JointRef child=Topology)?;  

Link:
	'Link' name=ID
	('isReuseOf' isReuseOf=[Link])?
	decorator=LinkDecorator
;

LinkDecorator:
	{LinkDecorator} 
	inertial+=Inertial*	
	visual+=Visual*	
	collision+=Collision*
;

LinkRef:
	'add_to' ref=[Link|ID] 
	decorator=LinkDecorator
;

Joint:
	'Joint' name=ID
	'ChildOf' ChildOf=[Link|ID]
	'ParentOf' ParentOf=[Link|ID]
	'Type' Type=JointType
	('isReuseOf' isReuseOf=[Joint])?
	decorator=JointDecorator
;

JointDecorator:
	{JointDecorator} 
	(limit=Limit)?
	(axis=Axis)?
	(calibration=Calibration)?
	(dynamics=Dynamics)?
	(safetycontroller=SafetyController)?
;

JointDecoRef:
	'add_to' ref=[Joint|ID]
	decorator=JointDecorator
;

enum JointType:
		fixed = 'Fixed' |revolute = 'Revolute' |  prismatic = 'Prismatic' | continuous = 'Continuous';
		
JointRef:
	 fix = '->' | rev = 'r->' | pris = 'p->' | cont = 'c->'  
;		

Inertial:
		{Inertial} 'Inertial' (name=ID)?
		inertia=Inertia
		mass=Mass
		(origin=Origin)?
;

Inertia returns Inertia:
	'Inertia' (name=ID)?
	'ixx' ixx=URDFAttrSignedNumeric 
	'ixy' ixy=URDFAttrSignedNumeric
	'ixz' ixz=URDFAttrSignedNumeric
	'iyy' iyy=URDFAttrSignedNumeric
	'iyz' iyz=URDFAttrSignedNumeric
	'izz' izz=URDFAttrSignedNumeric
;


Visual:
	{Visual} 'Visual' (name=ID)? 
	geometry+=Geometry*
	(origin=Origin)?
	//material=Material
;

Geometry:
	Box | Cylinder | Mesh | Sphere
	
;

//Tjek spec: order listing of dimensions?
Box:
	'Box' (name=ID)?
	'height' height=URDFAttrNumeric 
	'length' length=URDFAttrNumeric
	'width' width=URDFAttrNumeric 
;

Cylinder:
	'Cylinder' (name=ID)?
	'radius' radius=URDFAttrNumeric
	'length' length=URDFAttrNumeric	
;

//TODO: create ValueConverter to convert scale to Box
Mesh:
	'Mesh' (name=ID)?
	'pathToFile' pathToFile=URDFAttrSTRING
	('scale' dimension=Box)?
;

Sphere:
	'Sphere' (name=ID)?
	'radius' radius=URDFAttrNumeric	
;


Collision:
	{Collision} 'Collision' (name=ID)?
	geometry+=Geometry*
	(origin=Origin)?
;

Origin:
    'Origin' (name=ID)?
    'x' x=URDFAttrSignedNumeric 
	'y' y=URDFAttrSignedNumeric
	'z' z=URDFAttrSignedNumeric 
    ('roll' roll=URDFAttrSignedNumeric)?
	('pitch' pitch=URDFAttrSignedNumeric)? 
	('yaw' yaw=URDFAttrSignedNumeric)?
;

Mass:
	'Mass' (name=ID)?
	'mass_(ValueInKilograms)' massValueInKilograms=URDFAttrNumeric
;

Material:
	Color | Texture;


/* RGBA values must be floats between 0 and 1 incl */
Color:
	'Color' (name=ID)?
	'red' red=URDFAttrFloat 
	'green' green=URDFAttrFloat 
	'blue' blue=URDFAttrFloat 
	'alpha' alpha=URDFAttrFloat	
;

Texture:
	'Texture' (name=ID)?
	'pathToFile' pathToFile=URDFAttrSTRING
;

Limit:
	'Limit' (name=ID)?
	'effort' effort=URDFAttrSignedNumeric 
	'velocity' velocity=URDFAttrSignedNumeric 
	'lower' lower=(URDFAttrSignedNumeric)?
	'upper' upper=(URDFAttrSignedNumeric)? 
;

/* Binary values must be 0 or 1 - 
 * digitsum must be 1*/
//keyword aliases: 'xyz' or 'x', 'y', 'z'
Axis:
	'Axis' (name=ID)?
	'x' x=URDFAttrINT
	'y' y=URDFAttrINT
	'z' z=URDFAttrINT
    
;

Calibration:
	 {Calibration} 'Calibration' (name=ID)?
	 ('rising' rising=URDFAttrSignedNumeric)? 
	 ('falling' falling=URDFAttrSignedNumeric)? 
;

Dynamics:
	{Dynamics} 'Dynamics' (name=ID)?
	('friction' friction=URDFAttrSignedNumeric)?
	('damping' damping=URDFAttrSignedNumeric)?
;

//Should we cut Mimic from the spec??
/*Mimic:
	'Mimic' (name=ID)?
	'mimics' mimics=[Joint|ID]
	('multiplier' multiplier=SIGNED_NUMERIC)?
	('offSet' offSet=SIGNED_NUMERIC)?
;*/

SafetyController:
	'SafetyController' (name=ID)?
	('softLowerLimit' softLowerLimit=URDFAttrSignedNumeric)?
	('softUpperLimit' softUpperLimit=URDFAttrSignedNumeric)?
	('k_position' k_position=URDFAttrSignedNumeric)?
	'k_velocity' k_velocity=URDFAttrSignedNumeric
;

/*Constant:
	
;*/
	
URDFAttrSignedNumeric:
	value = SIGNED_NUMERIC
;

URDFAttrFloat:
	value = FLOAT
;

URDFAttrINT:
	value = INT
;

URDFAttrNumeric:
	value = NUMERIC
;

URDFAttrSTRING:
	value = STRING
;

FLOAT returns ecore::EFloat: 
	INT '.' INT
;

SCIENTIFIC returns ecore::EBigDecimal:
	FLOAT 'e' ('+' | '-')? INT 
;

SIGNED_NUMERIC:
	('-')? (INT | FLOAT | SCIENTIFIC)
;

NUMERIC:
	INT | FLOAT | SCIENTIFIC
;



